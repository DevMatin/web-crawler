-- ============================================
-- 03_views_and_refresh.sql
-- Materialized View, Refresh-Logik & Reporting-Views
-- ============================================

-- =======================
-- 1) Stale-Content Materialized View
-- =======================

-- Alte Version (falls vorhanden) entfernen
DROP MATERIALIZED VIEW IF EXISTS stale_content_view;

-- Materialized View für veraltete Inhalte (z.B. älter als 90 Tage)
CREATE MATERIALIZED VIEW stale_content_view AS
SELECT
  id,
  project_id,
  keyword_id,
  status,
  updated_at
FROM generated_content
WHERE status = 'published'
  AND updated_at < NOW() - INTERVAL '90 days';

-- Unique Index auf id, damit REFRESH MATERIALIZED VIEW CONCURRENTLY möglich ist
CREATE UNIQUE INDEX IF NOT EXISTS stale_content_view_id_idx
  ON stale_content_view(id);


-- =======================
-- 2) Refresh-Funktion: generate_refresh_tasks_concurrent()
-- =======================

CREATE OR REPLACE FUNCTION generate_refresh_tasks_concurrent()
RETURNS void AS $$
BEGIN
  -- Mat-View ohne Lock für Leser aktualisieren
  REFRESH MATERIALIZED VIEW CONCURRENTLY stale_content_view;

  -- Für alle veralteten Inhalte neue "content-refresh" Tasks erzeugen
  INSERT INTO content_tasks (project_id, keyword_id, task_type, status, priority)
  SELECT
    project_id,
    keyword_id,
    'content-refresh',
    'pending',
    5
  FROM stale_content_view
  WHERE keyword_id IS NOT NULL;
END;
$$ LANGUAGE plpgsql;


-- =======================
-- 3) Public Content View (API-ready, ohne interne IDs)
-- =======================

DROP VIEW IF EXISTS public_content_view;

CREATE OR REPLACE VIEW public_content_view AS
SELECT
  gc.uuid,           -- public Content UUID
  p.uuid AS project_uuid, -- public Project UUID
  gc.slug,
  gc.title,
  gc.meta_description,
  gc.h1,
  gc.content_html,
  gc.updated_at,
  gc.created_at
FROM generated_content gc
JOIN projects p ON gc.project_id = p.id
WHERE gc.status = 'published';

-- Typische REST-Route über Supabase:
--   /rest/v1/public_content_view?project_uuid=eq.<UUID>&slug=eq.<slug>


-- =======================
-- 4) Dashboard View: project_content_score_avg
-- =======================

DROP VIEW IF EXISTS project_content_score_avg;

CREATE OR REPLACE VIEW project_content_score_avg AS
SELECT
  project_id,
  AVG(impact_score)  AS avg_impact_score,
  AVG(quality_score) AS avg_quality_score,
  COUNT(*)           AS total_content_tasks
FROM content_tasks
GROUP BY project_id;


-- =======================
-- 5) Dashboard View: project_keyword_coverage
-- =======================

DROP VIEW IF EXISTS project_keyword_coverage;

CREATE OR REPLACE VIEW project_keyword_coverage AS
SELECT
  k.project_id,
  COUNT(*) AS total_keywords,
  (
    SELECT COUNT(DISTINCT pk.keyword_id)
    FROM page_keywords pk
    JOIN pages pg ON pk.page_id = pg.id
    WHERE pg.project_id = k.project_id
  ) AS covered_keywords
FROM keywords k
GROUP BY k.project_id;


-- =======================
-- 6) Dashboard View: content_update_needed
-- =======================

DROP VIEW IF EXISTS content_update_needed;

CREATE OR REPLACE VIEW content_update_needed AS
SELECT *
FROM generated_content
WHERE status = 'published'
  AND updated_at < NOW() - INTERVAL '60 days';
